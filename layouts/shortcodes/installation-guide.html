{{- /* 
Installation Guide Shortcode
Zeigt einen Selection Guide für Installation basierend auf Kategorien
Die gültigen Kombinationen werden aus den existierenden Seiten bestimmt
*/ -}}

{{- $lang := .Page.Lang | default "de" -}}
{{- $guideId := .Get "id" | default "installationGuide" -}}

{{- /* Kategorien definieren (deutsch) */ -}}
{{- $categories := dict
  "computer" (dict "label" "Control-Computer" "options" (slice 
    (dict "id" "pc" "label" "PC")
    (dict "id" "raspberry-pi" "label" "Raspberry-Pi")
  ))
  "wandler" (dict "label" "Signalwandler" "options" (slice
    (dict "id" "stemlab" "label" "STEMLAB")
    (dict "id" "fl2k-dongle" "label" "fl2k-Dongle")
    (dict "id" "adalm2000" "label" "ADALM2000")
  ))
  "os" (dict "label" "Betriebssystem" "options" (slice
    (dict "id" "windows" "label" "Windows")
    (dict "id" "linux" "label" "Linux")
  ))
  "software" (dict "label" "Software" "options" (slice
    (dict "id" "cohiwizard-exe" "label" "COHIWizard exe")
    (dict "id" "cohiwizard-python" "label" "COHIWizard Python")
    (dict "id" "cohi-player-mini" "label" "COHI-Player Mini")
  ))
-}}

{{- /* Scan alle Unterseiten und extrahiere gültige Kombinationen */ -}}
{{- $validCombos := slice -}}
{{- $currentPage := .Page -}}

{{- range $currentPage.Sections -}}
  {{- if .Params.combo -}}
    {{- $combo := .Params.combo -}}
    {{- if and $combo.computer $combo.wandler $combo.os $combo.software -}}
      {{- $comboStr := printf "%s-%s-%s-%s" $combo.computer $combo.wandler $combo.os $combo.software -}}
      {{- $validCombos = $validCombos | append $comboStr -}}
    {{- end -}}
  {{- end -}}
{{- end -}}

{{- /* Als JSON für JavaScript verfügbar machen */ -}}
{{- $validCombosJson := jsonify $validCombos -}}

<div class="installation-guide-wrapper" id="{{ $guideId }}" data-valid-combos='{{ $validCombosJson }}' data-debug-count="{{ len $validCombos }}">
  <div class="installation-guide-form">
    
    {{- range $catKey, $catData := $categories }}
    <div class="guide-category mb-4">
      <h5 class="guide-category-label mb-3">{{ $catData.label }}</h5>
      <div class="guide-options">
        {{- range $catData.options }}
        <div class="form-check">
          <input 
            class="form-check-input guide-radio" 
            type="radio" 
            name="category-{{ $catKey }}" 
            id="option-{{ .id }}" 
            value="{{ .id }}"
            data-category="{{ $catKey }}"
          >
          <label class="form-check-label" for="option-{{ .id }}">
            {{ .label }}
          </label>
        </div>
        {{- end }}
      </div>
    </div>
    {{- end }}

    <div class="guide-actions mt-5">
      <button id="guide-submit" class="btn btn-primary" disabled>
        <span class="btn-text">Auswählen</span>
      </button>
    </div>
  </div>
</div>

<script>
(function() {
  const guideId = "{{ $guideId }}";
  const wrapper = document.getElementById(guideId);
  if (!wrapper) return;

  const validCombosRaw = wrapper.dataset.validCombos || "[]";
  let validCombos = [];
  try {
    validCombos = JSON.parse(validCombosRaw);
  } catch (e) {
    console.error("Invalid validCombos JSON:", e);
  }

  const submitBtn = document.getElementById("guide-submit");
  const radioButtons = wrapper.querySelectorAll(".guide-radio");
  const categories = ["computer", "wandler", "os", "software"];

  console.log("=== INSTALLATION GUIDE DEBUG ===");
  console.log("Valid combos found:", validCombos);
  console.log("Raw JSON:", validCombosRaw);
  console.log("Debug count:", wrapper.dataset.debugCount);
  console.log("=====================================");

  /**
   * Prüft ob es mindestens eine gültige Kombination gibt,
   * die diese Radio-Option UND alle aktuellen Selektionen enthält
   */
  function isRadioOptionValid(testRadio) {
    const testCategory = testRadio.dataset.category;
    const testValue = testRadio.value;

    // Sammle alle bereits gewählten Kategorien
    const selections = {};
    radioButtons.forEach(radio => {
      if (radio.checked && radio.dataset.category !== testCategory) {
        selections[radio.dataset.category] = radio.value;
      }
    });

    // Prüfe ob es mindestens eine gültige Kombo gibt, die:
    // 1. Diese Radio-Option enthält
    // 2. Alle bisherigen Selektionen erfüllt
    
    const matchingCombos = validCombos.filter(combo => {
      // Combo-String z.B. "pc-stemlab-windows-cohiwizard-exe"
      // Muss die Option mit ihrem Wert enthalten
      
      // Prüfe ob dieser Wert in der Kombo vorkommt
      if (!combo.includes(testValue)) {
        return false;
      }
      
      // Prüfe ob alle bereits gewählten Selektionen in dieser Kombo vorhanden sind
      for (const [cat, val] of Object.entries(selections)) {
        if (!combo.includes(val)) {
          return false;
        }
      }
      
      return true;
    });

    return matchingCombos.length > 0;
  }

  /**
   * Disablet/enablet Radiobuttons basierend auf gültigen Kombinationen
   */
  function updateDisabledStates() {
    // Zähle wie viele Kategorien bereits ausgewählt sind
    let selectedCount = 0;
    categories.forEach(cat => {
      if (wrapper.querySelector(`input[data-category="${cat}"]:checked`)) {
        selectedCount++;
      }
    });

    radioButtons.forEach(radio => {
      // Beim initialen Load (keine Auswahl): alles enabled
      if (selectedCount === 0) {
        radio.disabled = false;
        const label = wrapper.querySelector(`label[for="${radio.id}"]`);
        if (label) {
          label.classList.remove("opacity-50", "text-muted");
        }
      } else {
        // Wenn Auswahl gemacht wurde: prüfe Kompatibilität
        const isValid = isRadioOptionValid(radio);
        radio.disabled = !isValid;
        
        const label = wrapper.querySelector(`label[for="${radio.id}"]`);
        if (label) {
          if (radio.disabled) {
            label.classList.add("opacity-50", "text-muted");
          } else {
            label.classList.remove("opacity-50", "text-muted");
          }
        }
      }
    });

    // Submitbutton enablen wenn alle 4 Kategorien gewählt
    const allSelected = categories.every(cat => {
      return wrapper.querySelector(`input[data-category="${cat}"]:checked`);
    });

    submitBtn.disabled = !allSelected;
  }

  /**
   * Erstellt den Ziellink aus Kombination
   */
  function buildTargetUrl() {
    const selections = {};
    radioButtons.forEach(radio => {
      if (radio.checked) {
        selections[radio.dataset.category] = radio.value;
      }
    });

    const combo = [
      selections.computer,
      selections.wandler,
      selections.os,
      selections.software
    ].join("-");

    const basePath = "{{ .Page.RelPermalink }}";
    return basePath + combo + "/";
  }

  // Event Listener
  radioButtons.forEach(radio => {
    radio.addEventListener("change", updateDisabledStates);
  });

  submitBtn.addEventListener("click", () => {
    const url = buildTargetUrl();
    window.location.href = url;
  });

  // Initial state
  updateDisabledStates();
})();
</script>

<style>
.installation-guide-wrapper {
  margin: 2rem 0;
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 0.375rem;
  border-left: 4px solid #0d6efd;
}

.guide-category {
  padding: 1rem 0;
}

.guide-category-label {
  font-weight: 600;
  color: #212529;
  margin-bottom: 0.75rem;
}

.guide-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 0.75rem;
}

.guide-options .form-check {
  padding: 0.5rem;
  border-radius: 0.25rem;
  transition: background-color 0.2s;
}

.guide-options .form-check:hover:not(.disabled) {
  background-color: rgba(13, 110, 253, 0.1);
}

.guide-options .form-check-input:disabled + .form-check-label {
  opacity: 0.5;
  color: #6c757d;
  cursor: not-allowed;
}

.guide-actions {
  display: flex;
  gap: 0.5rem;
  margin-top: 2rem;
  padding-top: 1.5rem;
  border-top: 1px solid #dee2e6;
}

.guide-actions .btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.opacity-50 {
  opacity: 0.5;
}

.text-muted {
  color: #6c757d !important;
}
</style>
